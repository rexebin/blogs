# Angular依赖注入服务的作用范围之概论

本文针对的是对Angular的多级依赖注入系统、模块和路由有一定了解的读者群体。**本文的重点在于讲述依赖注入服务的作用范围**。推荐阅读官方的下列文档：

1. [依赖注入](https://angular.cn/docs/ts/latest/guide/dependency-injection.html)
1. [多级依赖注入](https://angular.cn/docs/ts/latest/guide/hierarchical-dependency-injection.html)
1. [Angular模块（NgModule）](https://angular.cn/docs/ts/latest/guide/ngmodule.html)
1. [路由与导航](https://angular.cn/docs/ts/latest/guide/router.html)
1. [Angular模块常见问题](https://angular.cn/docs/ts/latest/cookbook/ngmodule-faq.html)

Angular的依赖注入系统是它最重要的特征之一，它是一种即时创建和提供服务的机制。理解该机制是编写Angular应用的基本条件之一。

Angular为每个模块、组件和指令都准备了一份注入器，这些注入器上下关联，形成一个树形结构。一般来讲，应用级别根注入器处于树尖，下面是组件注入器和懒惰加载模块的根注入器。

那么服务跟注入器有啥关系？你可以把注入器看作服务的容器。我们通过将服务的令牌，添加到模块、组件和指令的元数据的服务提供商(providers)数组中，来将它们注册到对应注入器中。

## 依赖注入机制

### 特征
Angular依赖注入系统有下面几个特征：

1. **单例**：

    所谓单例，针对的是注入器，而非服务的类。它不是说一个服务类只能实例化一次，而是指在任何一级注入器所创建的服务实例是唯一的。所谓唯一，是在它作用范围内的任何角落，将该服务注入进来，所得到的都是同一个实例，同一个对象，拥有同样的属性和值。
    
    假设一个组件更改了一个服务实例的某属性的值，之后，在其它组件注入同一服务时，所得到的将是同一个属性已经变化了的实例，这正是为什么我们可以使用服务在组件中共享数据的原因。

    服务类可以在多级注入器被多次创建，从而产生多个实例。每个实例在自己的作用域内都是单例的。    

1. **作用域由上至下**：

    在任何一级注入器所创建的服务实例，它的作用范围辐射并局限于自己以及所有子级。注意，该实例的上级或者邻居对其无访问权。

1. **服务查询由下至上**：

    当一个组件、指令、服务和管道等在其类构造函数中请求一个服务时，Angular从当前类所在的注入器开始寻找。如果没有找到合适的服务提供商，那么Angular便向上一级注入器查询，以此类推，直到找到第一个拥有合适提供商的注入器，然后：（1）如果该级注入器还没有所需服务的实例，Angular则创建一个实例并完成注入。（2）如果该级注入器已经存有所需服务的实例，则直接使用现有实例注入。

    如果一路查询到根注入器都没有找到合适的提供商，那么Angular便会报错。

    **值得注意的是，当Angular由下至上找到第一个合适的服务后，它将立刻停止查找，忽略上面所有注入器。** 这样确保了每个依赖请求都有一个可以预见的服务对应。

### 分级规则

如何决定谁是上级，谁是下级呢？有以下几种情况：

1. 根模块的注入器为根注入器，所有其它注入器都是它的子级。**根注入器中的服务的作用范围贯穿整个应用**。

1. 主动加载模块的提供商会被升级到根模块注入器中。

1. 懒惰加载模块拥有独立的根注入器，它的上级是宿主模块的根注入器，下级为本模块内其它注入器。

1. **包容规则**：

    * 宿主组件是视图子级(ViewChildren)和内容子级(ContentChildren)的上级。

        - 视图子级是在宿主组件模板中使用的组件和指令。

        - 内容子级是宿主组件选择器中间包含的内容，比如
            ```
            <parent-component>
                <content-children></content-children>    
            </parent-component>
            ```
    * 入口组件的包容规则： 

        只通过路由访问的组件被称为入口组件，它一般带有`<router-outlet>`路由插座。

        其他组件一般被路由器放置到入口组件的路由插座的隔壁，请注意，路由器**不会**将组件插入到`<router-outlet>`内。

        - 路由器将主动加载模块的组件插入到带有`<router-outlet>`宿主组件时，入口组件是被插入组件的父级。

        - 路由器将懒惰加载模块的组件插入到带有`<router-outlet>`宿主组件时，入口组件**不是**被插入组件的父级。参见[下面](#懒惰加载模块)的解释。

# Angular服务的作用范围

## 根模块、主动加载模块和懒惰加载模块的服务

### 模块

Angular模块是带有@NgModule装饰器函数的类，用来管理整个Angular应用的所有组件、指令、管道和服务等。几乎所有Angular自带程序库、外部程序库都是以模块的形式封装的。
详情参见[Angular模块（NgModule）](https://angular.cn/docs/ts/latest/guide/ngmodule.html)和[Angular模块常见问题](https://angular.cn/docs/ts/latest/cookbook/ngmodule-faq.html)。

每个Angular应用都有一个根模块，它是用来配置所有应用级别范围服务的最佳地点。

模块分为两种：主动加载模块和懒惰加载模块。

1. 主动加载模块是在Angular启动时，会被自动加载的模块，一般是Angular应用启动后的默认视图和少数需要的支持模块。

1. 懒惰加载模块在Angular启动时不会被立刻加载，而是在用户通过路由器第一次访问该模块时才被加载。除了少数主动加载模块外，所有其它模块都应该设计为懒惰加载模块。 

Angular对主动加载模块和懒惰加载模块的提供商的处理方法**截然不同**。

### 主动加载模块

主动加载模块的服务提供商被Angular升级到根注入器中，作用范围贯穿整个应用。这样设计的主要原因是为了让我们能够通过模块扩展应用。见下图所示：
<img src="https://github.com/rexebin/blogs/blob/master/eager%20load%20module.PNG">

重点有以下几点:

1. 主动加载模块的提供商被提升到根注入器中。**不要在主动加载模块中注册任何提供商**

1. 动加载的模块是应用宿主组件（比如AppComponent）的子级，它们可以注入应用宿主组件的提供商。

最佳实践为：

1. 为所有全局服务提供商创建一个名为Core Module主动加载模块
    * 将根模块的提供商移到Core Module里
    * 不要在除了Core Module之外的任何主动加载模块中注册任何提供商
    * 在Core Module里导入公用模块库，比如表单库、路由库等
1. **只**在根模块中导入Core Module    

### 懒惰加载模块

<img src="https://github.com/rexebin/blogs/blob/master/lazy%20load.PNG">

重点有以下几点：

1. 懒惰加载模块拥有自己独立的注入器，服务的作用贯穿整个模块
1. 懒惰加载模块的根注入器被提升为宿主模块根注入器的直属子级，而不会像主动加载模块那样被升级进根注入器。
1. 虽然懒惰加载模块一般被路由器加载到带有<router-outlet>的宿主/入口组件中，但是懒惰加载模块的根注入器不是宿主组件或入口组件注入器的子级，所以无法注入它们的服务提供商        
    
提供服务的最佳实践是使用模块来配置服务提供商，除非想要将服务提供商的作用域控制在组件树内。

## 组件级服务范围

如果想要将服务提供商的作用范围控制在组件以及它的子级之内，则在组件内提供服务，将服务提供商添加到组件元数据的providers数组中即可。

组件级注入器的上下级按**[包容规则](#分级规则)**排列。