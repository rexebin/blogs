# Angular依赖注入服务的作用范围之概论

本文针对的是对Angular的多级依赖注入系统、模块和路由有一定了解的读者群体。**本文的重点在于讲述依赖注入服务的作用范围**。推荐阅读官方的下列文档：

1. [依赖注入](https://angular.cn/docs/ts/latest/guide/dependency-injection.html)
1. [多级依赖注入](https://angular.cn/docs/ts/latest/guide/hierarchical-dependency-injection.html)
1. [Angular模块（NgModule）](https://angular.cn/docs/ts/latest/guide/ngmodule.html)
1. [路由与导航](https://angular.cn/docs/ts/latest/guide/router.html)
1. [Angular模块常见问题](https://angular.cn/docs/ts/latest/cookbook/ngmodule-faq.html)

Angular的依赖注入系统是它最重要的特征之一，它是一种即时创建和提供服务的机制。理解该机制是编写Angular应用的基本条件之一。

Angular为每个模块、组件和指令都准备了一份注入器，这些注入器上下关联，形成一个树形结构。一般来讲，应用级别根注入器处于树尖，下面是组件注入器和懒惰加载模块的根注入器。

那么服务跟注入器有啥关系？你可以把注入器看作服务的容器。我们通过将服务的令牌添加到模块、组件和指令的元数据的服务提供商(providers)数组中，来将它们注册到对应注入器中。

Angular依赖注入系统提供服务的机制有下面几个特征：

1. **单例**：

    服务类可以在多级注入器被多次创建，从而产生多个实例。每个实例在自己的作用域内都是单例的。

    所谓单例，针对的是注入器，而非服务的类。它不是说一个服务类只能实例化一次，而是指在任何一级注入器所创建的服务实例是唯一的。所谓唯一，是在它作用范围内的任何角落，将该服务注入进来，所得到的都是同一个实例，同一个对象，拥有同样的属性和值。
    
    假设一个组件更改了一个服务实例的某属性的值，之后，在其它组件注入同一服务时，所得到的将是同一个属性已经变化了的实例，这正是为什么我们可以使用服务在组件中共享数据的原因。    

1. **作用域由上至下**：

    在任何一级注入器所创建的服务实例，它的作用范围辐射并局限于自己以及所有子级。注意，该实例的上级或者邻居对其无访问权。

1. **服务查询由下至上**：

    当一个组件、指令、服务和管道等在其类构造函数中请求一个服务时，Angular从当前类所在的注入器开始寻找。如果没有找到合适的服务提供商，那么Angular便向上一级注入器查询，以此类推，直到找到第一个拥有合适提供商的注入器，然后：（1）如果该级注入器还没有所需服务的实例，Angular则创建一个实例并完成注入。（2）如果该级注入器已经存有所需服务的实例，则直接使用现有实例注入。

    如果一路查询到根注入器都没有找到合适的提供商，那么Angular便会报错。

    **值得注意的是，当Angular由下至上找到第一个合适的服务后，它将立刻停止查找，忽略上面所有注入器。** 这样确保了每个依赖请求都有一个可以预见的服务对应。

如何决定谁是上级，谁是下级呢？有以下几种情况：

1. 根模块的注入器为根注入器，所有其它注入器都是它的子级。**根注入器中的服务的作用范围贯穿整个应用**。

1. 主动加载模块的提供商会被升级到根模块注入器中。

1. 懒惰加载模块的根注入器直属是本模块内其它注入器的上级，是宿主模块根注入器的直属下级。

1. **包容规则**：

    * 宿主组件是视图子级(ViewChildren)和内容子级(ContentChildren)的上级。

        - 视图子级是在宿主组件模板中使用的组件和指令。

        - 内容子级是宿主组件选择器中间包含的内容，比如
            ```
            <parent-component>
                <content-children></content-children>    
            </parent-component>
            ```
    * 路由器将主动加载模块的组件插入到带有<router-outlet>宿主组件时，宿主组件是被插入组件的父级。
    * 路由器将懒惰加载模块的组件插入到带有<router-outlet>宿主组件时，宿主组件**不是**被插入组件的父级。参见下面的解释。

# Angular服务的作用范围

## 根模块、主动加载模块和懒惰加载模块的服务

### 模块

Angular模块是带有@NgModule装饰器函数的类，用来管理整个Angular应用的所有组件、指令、管道和服务等。几乎所有Angular自带程序库、外部程序库都是以模块的形式封装的。
详情参见[Angular模块（NgModule）](https://angular.cn/docs/ts/latest/guide/ngmodule.html)和[Angular模块常见问题](https://angular.cn/docs/ts/latest/cookbook/ngmodule-faq.html)。

每个Angular应用都有一个根模块，它是用来配置所有应用级别范围服务的最佳地点。

### 特性模块

特性模块分为两种：主动加载模块和懒惰加载模块。

1. 主动加载模块是在Angular启动时，会被自动加载的模块，一般是Angular应用启动后的默认视图和少数需要的支持模块。

1. 懒惰加载模块在Angular启动时不会被立刻加载，而是在用户通过路由器第一次访问该模块时才被加载。除了少数主动加载模块外，所有其它模块都应该设计为懒惰加载模块。 

Angular对主动加载模块和懒惰加载模块的提供商的处理方法**截然不同**。

1. 主动加载模块的服务提供商被Angular升级到根注入器中，作用范围贯穿整个应用。这样设计的主要原因是为了让我们能够通过模块扩展应用。见下图所示：
    <img src="https://github.com/rexebin/blogs/blob/master/eager%20load%20module.PNG">

    需要注意的重点有以下几点:

    * 主动加载模块的提供商被提升到根注入器中。**不要在主动加载模块中注册任何提供商**

    * 主动加载的模块是应用宿主组件（比如AppComponent）的子级，它们可以注入应用宿主组件的提供商。

    建议最佳实践为：

    1. 为所有全局服务提供商创建一个名为Core Module主动加载模块
        * 将根模块的提供商移到Core Module里
        * 不要在主动加载模块中注册任何提供商，除了Core Module之外
        * 在Core Module里导入公用模块库，比如表单库、路由库等
    1. **只**在根模块中导入Core Module    

1. 懒惰加载模块

    * 懒惰加载模块拥有自己独立的注入器，它的服务提供商不会像主动加载模块那样被升级到根注入器，而是被提升为宿主模块根注入器的直属子级，服务的作用贯穿整个模块。原因有两点：

        - Angular的注入器被第一次调用后，将无法再对其进行配置。所以在根注入器被配置并启用以后，它已经被关闭，无法再向其添加服务。所以就算Angular开发小组想要升级懒惰加载的服务到根注入器，也是无法做到的。

        - 懒惰加载拥有自己的独立注入器，为我们提供了一种将服务作用域控制在模块内的方法。

    * 懒惰加载模块的注入器的上级总是根注入器。不管懒惰加载模块从哪儿被加载，它的注入器将总是被升级，并成为根注入器的直接子级。这么设计的原因有：

        - 懒惰加载模块是由路由动态加载的模块，它总是被加载到某含有<router-outlet>元素的宿主组件。假设包容规则对懒惰加载模块有效，那么懒惰加载模块注入器的上级则会是某含有<router-outlet>元素的宿主组件，该宿主组件可能属于某主动或懒惰加载模块，这些模块有可能是其他宿主组件的子级，以此类推。这样的注入器层次系统就显得非常混乱和难以控制了。我们将很难预见懒惰加载模块中有什么服务可用。

        - **为了确保懒惰加载模块可以完全独立并自包含，避免注入器层次混乱**， Angular将懒惰加载模块的注入器升级为根注入器的直属子级。
        
    **综上所述，在懒惰加载模块中能见的服务为：1）属于根注入器的全局服务，2）懒惰加载模块自己提供的服务和导入的模块提供的服务。懒惰加载模块无法注入其他任何服务**

提供服务的最佳实践是使用模块来配置服务提供商，除非想要将服务提供商的作用域控制在组件树内。参见[下面](#组件级服务)的解释。

## 组件级服务

如果想要将服务提供商的作用范围控制在组件以及它的子级之内，则在组件内提供服务，将服务提供商添加到组件元数据的providers数组中即可。

1. 每次Angular创建该组件的实例时，都会创建并注入一个新的服务实例。该实例的作用范围覆盖所有子级组件。
1. 如果该组件没有任何子级，它的服务则只为自己所用。并且，Angular在每次创建该组件时，都会创建新的服务实例。

## 路由组件和子级路由组件的服务

通过路由访问的组件包括两种：
1. 带有<router-outlet></router-outlet>路由插座的宿主组件
1. 被路由器放置到路由插座的隔壁，请注意，路由器**不会**将组件插入到<router-outlet>内。

在上面的组件中，服务提供商的作用域是什么呢？首先我们要弄清楚注入器的上下级关系：<router-outlet>所在宿主组件包含了被插入进来的模块或组件。

不难看出，服务的作用域为：

1. 宿主组件注入器的服务覆盖所有被注入到器路由插座的所有组件，懒惰加载模块除外，因为懒惰加载的模块的注入器被升级为根注入器的直属下级。
1. 被路由器平行放置到路由插座所在宿主组件中的所有组件之间并无父子关系，所以它们的服务不能被互相访问。 

Angular的依赖注入系统对Angular开发者非常重要。自从Angular在RC5之后引入了Angular模块和推出了新的路由器以后，依赖注入机制变得更加复杂。

要充分理解依赖注入系统，笔者推荐读者先阅读官方关于依赖注入的文档，然后再进一步了解Angular模块和路由是如何与依赖注入系统共同工作的。